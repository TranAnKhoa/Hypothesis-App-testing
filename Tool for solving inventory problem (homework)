
#! NAME: Trần An Khoa - BONUS HW2 Inventory
#! STUDENT ID: IELSIU23040

import pandas as pd
import numpy as np
import time
import matplotlib.pyplot as plt
import seaborn as sns

# --- 1. Các Hàm Phương Pháp Tồn Kho (Đã sửa đổi theo logic yêu cầu) ---

#! Hàm tính L4L method (Logic gốc đã chính xác)
def calculate_l4l(demands, setup_cost, buying_cost, r):
    """
    Triển khai mô hình tồn kho Lot-for-Lot (L4L).
    Nguyên tắc: Đặt hàng đúng bằng nhu cầu mỗi kỳ. Chi phí lưu kho bằng 0.
    """
    # Tính chi phí lưu kho trên mỗi đơn vị (h) từ tỷ lệ r
    holding_cost = buying_cost * r
    n_periods = len(demands)
    data = []
    # Biến này chỉ cộng dồn chi phí tồn kho (Setup + Holding) để so sánh
    total_inventory_cost = 0

    for i in range(n_periods):
        period = i + 1
        demand = demands[i]
        
        order_quantity = demand
        ending_inventory = 0
        current_holding_cost = 0 # Luôn bằng 0 trong L4L
        current_setup_cost = setup_cost if order_quantity > 0 else 0
        current_buying_cost = order_quantity * buying_cost
        
        total_period_cost = current_holding_cost + current_setup_cost + current_buying_cost
        # Cộng dồn chi phí tồn kho (không bao gồm chi phí mua hàng)
        total_inventory_cost += current_holding_cost + current_setup_cost
        
        data.append([
            period, demand, order_quantity, ending_inventory,
            current_holding_cost, current_setup_cost, current_buying_cost, total_period_cost
        ])

    df = pd.DataFrame(data, columns=[
        'Period', 'Demand', 'Order Quantity', 'Ending Inventory',
        'Holding Cost', 'Setup Cost', 'Buying Cost', 'Total Period Cost'
    ])
    
    # Tổng chi phí kế hoạch = (chi phí tồn kho) + (tổng chi phí mua hàng)
    total_plan_cost = total_inventory_cost + (sum(demands) * buying_cost)
    return df, total_plan_cost

#! Hàm tính Silver-Meal (Logic gốc đã chính xác theo mô tả)
def calculate_sm(demands, setup_cost, buying_cost, r):
    """
    Silver–Meal heuristic (phiên bản chuẩn đầy đủ chi phí thực tế)
    Mục tiêu: tìm số kỳ nên gộp trong một lô hàng sao cho chi phí trung bình (z) nhỏ nhất,
    và tổng chi phí cuối cùng = ∑ (z_t × số kỳ được cover).
    """
    n_periods = len(demands)
    holding_cost_rate = r
    data = []
    total_cost = 0 # Tổng chi phí sẽ được cộng dồn từ các lô hàng
    current_period = 0 # Bắt đầu từ kỳ đầu tiên

    while current_period < n_periods: # Xử lý tuần tự từng lô hàng cho đến hết
        if demands[current_period] == 0:
            data.append([current_period + 1, 0, 0, 0, 0, 0, 0, 0])
            current_period += 1
            continue

        best_avg_cost_per_period = float('inf')
        periods_to_cover = 0

        # Vòng lặp này để "thử" gộp các kỳ tiếp theo và tìm chi phí trung bình tốt nhất
        for t in range(current_period, n_periods):
            num_periods_in_test_lot = t - current_period + 1
            total_demand_in_lot = sum(demands[current_period : t + 1])

            # Tính tổng chi phí lưu kho cho lô hàng đang "thử"
            holding_cost_for_test_lot = 0
            for k in range(current_period + 1, t + 1):
                holding_cost_for_test_lot += demands[k] * (k - current_period) * holding_cost_rate

            # Tính tổng chi phí đầy đủ (bao gồm cả mua hàng) cho lô hàng này
            total_cost_for_test_lot = (
                setup_cost
                + buying_cost * total_demand_in_lot
                + buying_cost * holding_cost_for_test_lot
            )

            # Tiêu chí của SM: Chi phí trung bình trên mỗi kỳ
            avg_cost_per_period = total_cost_for_test_lot / num_periods_in_test_lot
            print(f"z{current_period+1},{t+1} = {avg_cost_per_period:.2f}")

            # Nếu chi phí trung bình giảm thì tiếp tục, nếu bắt đầu tăng thì dừng lại
            if avg_cost_per_period < best_avg_cost_per_period:
                best_avg_cost_per_period = avg_cost_per_period
                periods_to_cover = num_periods_in_test_lot
            else:
                break # Dừng gộp khi chi phí trung bình bắt đầu tăng

        # --- Chốt lô hàng tối ưu ---
        end_period = current_period + periods_to_cover - 1
        order_quantity = sum(demands[current_period : end_period + 1])
        # Cộng dồn chi phí theo công thức z*tối ưu * số_kỳ
        batch_total_cost = best_avg_cost_per_period * periods_to_cover
        total_cost += batch_total_cost

        # Ghi lại kết quả chi tiết của từng kỳ trong lô hàng vừa chốt
        inventory_level = order_quantity
        for p_idx in range(current_period, end_period + 1):
            # ... (Phần ghi dữ liệu chi tiết)
            period = p_idx + 1
            demand = demands[p_idx]
            q_order, p_setup_cost, p_buying_cost = 0, 0, 0
            if p_idx == current_period:
                q_order = order_quantity
                p_setup_cost = setup_cost
                p_buying_cost = q_order * buying_cost
            inventory_level -= demand
            p_ending_inv = inventory_level
            p_holding_cost = p_ending_inv * buying_cost * holding_cost_rate
            p_total_cost = p_setup_cost + p_buying_cost + p_holding_cost
            data.append([
                period, demand, q_order, p_ending_inv,
                p_holding_cost, p_setup_cost, p_buying_cost, p_total_cost
            ])

        # Cập nhật để bắt đầu tìm lô hàng tiếp theo
        current_period = end_period + 1

    df = pd.DataFrame(data, columns=[
        'Period', 'Demand', 'Order Quantity', 'Ending Inventory',
        'Holding Cost', 'Setup Cost', 'Buying Cost', 'Total Period Cost'
    ]).sort_values(by='Period').reset_index(drop=True)

    print(f"\n✅ Tổng chi phí kế hoạch (theo công thức z*t): {total_cost:.2f}")
    return df, total_cost

def calculate_luc(demands, setup_cost, buying_cost, r):
    """
    Triển khai mô hình tồn kho Least Unit Cost (LUC) chính xác.
    - Ra quyết định dựa trên chi phí trung bình trên mỗi ĐƠN VỊ sản phẩm.
    """
    holding_cost = buying_cost * r
    n_periods = len(demands)
    data = []
    total_plan_cost = 0
    
    current_period = 0
    while current_period < n_periods: # Xử lý tuần tự từng lô hàng
        if demands[current_period] == 0:
            data.append([current_period + 1, 0, 0, 0, 0, 0, 0, 0])
            current_period += 1
            continue
        
        best_avg_cost_per_unit = float('inf')
        periods_to_cover = 0
        best_z = None
        
        # "Thử" gộp các kỳ để tìm chi phí trên đơn vị thấp nhất
        for t in range(current_period, n_periods):
            num_periods_in_test_lot = t - current_period + 1
            total_demand_in_test_lot = sum(demands[current_period:t+1])
            if total_demand_in_test_lot == 0: continue

            # Tính chi phí holding cho lô này (chỉ setup + holding)
            holding_cost_for_test_lot = 0
            for k in range(current_period + 1, t + 1):
                holding_cost_for_test_lot += demands[k] * (k - current_period) * holding_cost
            
            inventory_cost_for_test_lot = setup_cost + holding_cost_for_test_lot

            # Tiêu chí của LUC: Chi phí trung bình trên mỗi ĐƠN VỊ
            avg_cost_per_unit = inventory_cost_for_test_lot / total_demand_in_test_lot
            print(f"z{current_period+1},{t+1} = {avg_cost_per_unit:.4f}")

            if avg_cost_per_unit < best_avg_cost_per_unit:
                best_avg_cost_per_unit = avg_cost_per_unit
                best_z = avg_cost_per_unit
                periods_to_cover = num_periods_in_test_lot
            else:
                break # Dừng khi chi phí trên đơn vị bắt đầu tăng

        # --- Chốt lô hàng ---
        end_period_for_batch = current_period + periods_to_cover - 1
        order_quantity = sum(demands[current_period:end_period_for_batch+1])

        # Cộng dồn chi phí theo công thức z*tối ưu * tổng_nhu_cầu_lô
        total_plan_cost += best_z * order_quantity

        # Ghi lại chi tiết từng kỳ trong lô hàng đã chốt
        inventory_level = order_quantity
        for p_idx in range(current_period, end_period_for_batch + 1):
            # ... (Phần ghi dữ liệu chi tiết)
            period = p_idx + 1
            demand = demands[p_idx]
            q_order, p_setup_cost, p_buying_cost = 0, 0, 0
            if p_idx == current_period:
                q_order = order_quantity
                p_setup_cost = setup_cost if q_order > 0 else 0
                p_buying_cost = q_order * buying_cost
            inventory_level -= demand
            p_ending_inv = inventory_level
            p_holding_cost = p_ending_inv * holding_cost
            p_total_cost = p_holding_cost + p_setup_cost + p_buying_cost
            data.append([
                period, demand, q_order, p_ending_inv,
                p_holding_cost, p_setup_cost, p_buying_cost, p_total_cost
            ])

        current_period = end_period_for_batch + 1

    df = pd.DataFrame(data, columns=[
        'Period', 'Demand', 'Order Quantity', 'Ending Inventory',
        'Holding Cost', 'Setup Cost', 'Buying Cost', 'Total Period Cost'
    ]).sort_values(by='Period').reset_index(drop=True)
    
    # Cộng thêm tổng chi phí mua hàng vào cuối cùng để có chi phí tổng thể
    final_total_cost = total_plan_cost + (sum(demands) * buying_cost)
    return df, final_total_cost


#! Hàm tính Wagner-Whitin (ĐÃ VIẾT LẠI theo logic Quy hoạch động tiến)
def calculate_ww_dp(demands, setup_cost, buying_cost, r):
    """
    Triển khai thuật toán Wagner-Whitin (WW) bằng Quy hoạch động tiến.
    f(t) = min_{1<=j<=t} { f(j-1) + C_jt }
    """
    holding_cost = buying_cost * r
    n = len(demands)

    # f[t] = chi phí tồn kho TỐI THIỂU (setup + holding) cho các kỳ từ 1 đến t
    f = [float('inf')] * (n + 1)
    # last_order_period[t] = lưu lại kỳ j tối ưu cho bài toán con đến kỳ t
    last_order_period = [-1] * (n + 1)
    f[0] = 0 # Chi phí cho 0 kỳ là 0

    # Bước 1: Quy hoạch động tiến để tìm chi phí tối thiểu
    for t in range(1, n + 1):
        # j là kỳ bắt đầu của lô hàng cuối cùng có thể có
        for j in range(1, t + 1): 
            # Tính C_jt: chi phí nếu đặt hàng tại kỳ j để đáp ứng nhu cầu từ j đến t
            current_holding_cost = 0
            for i in range(j + 1, t + 1):
                current_holding_cost += demands[i - 1] * (i - j) * holding_cost
            
            c_jt = setup_cost + current_holding_cost
            
            # Áp dụng công thức đệ quy của Wagner-Whitin
            current_total_cost = f[j - 1] + c_jt
            if current_total_cost < f[t]:
                f[t] = current_total_cost
                last_order_period[t] = j - 1 # Lưu chỉ số (0-based) của kỳ đặt hàng tối ưu

    total_optimal_inventory_cost = f[n] # Chi phí tồn kho tối ưu là kết quả của bài toán n kỳ

    # Bước 2: Truy vết ngược để xây dựng lại lịch trình đặt hàng từ các quyết định đã lưu
    orders_indices = []
    current_t_index = n
    while current_t_index > 0:
        order_idx = last_order_period[current_t_index]
        orders_indices.append(order_idx)
        current_t_index = order_idx

    orders_indices.reverse() # Đảo ngược để có thứ tự đặt hàng đúng
    
    # Bước 3: Xây dựng bảng kế hoạch chi tiết từ lịch trình tối ưu
    order_plan = {order_idx: 0 for order_idx in orders_indices}
    for i in range(len(orders_indices)):
        start_idx = orders_indices[i]
        end_idx = n - 1
        if i + 1 < len(orders_indices):
            end_idx = orders_indices[i+1] - 1
        
        quantity = sum(demands[start_idx : end_idx + 1])
        order_plan[start_idx] = quantity

    # Ghi lại kết quả chi tiết của từng kỳ
    data = []
    inventory = 0
    for i in range(n):
        # ... (Phần ghi dữ liệu chi tiết)
        period = i + 1
        demand = demands[i]
        order_quantity = order_plan.get(i, 0)
        period_setup_cost = setup_cost if order_quantity > 0 else 0
        period_buying_cost = order_quantity * buying_cost
        inventory += order_quantity
        inventory -= demand
        period_holding_cost = inventory * holding_cost
        total_period_cost = period_holding_cost + period_setup_cost + period_buying_cost
        data.append([
            period, demand, order_quantity, inventory,
            period_holding_cost, period_setup_cost, period_buying_cost, total_period_cost
        ])
        
    df = pd.DataFrame(data, columns=[
        'Period', 'Demand', 'Order Quantity', 'Ending Inventory',
        'Holding Cost', 'Setup Cost', 'Buying Cost', 'Total Period Cost'
    ])
    
    # Tổng chi phí kế hoạch = (chi phí tồn kho tối ưu) + (tổng chi phí mua hàng)
    total_plan_cost = total_optimal_inventory_cost + (sum(demands) * buying_cost)
    return df, total_plan_cost


# --- 2. Thiết lập và Chạy Mô phỏng (Không thay đổi) ---

def generate_random_demands(num_periods, min_demand, max_demand, zero_demand_prob=0.2):
    # ... (Hàm tạo demands ngẫu nhiên)
    demands = []
    for _ in range(num_periods):
        if np.random.rand() < zero_demand_prob:
            demands.append(0)
        else:
            demands.append(np.random.randint(min_demand, max_demand + 1))
    return demands

# Dictionary chứa các hàm để gọi tự động
methods = {
    "L4L": calculate_l4l,
    "Silver-Meal": calculate_sm,
    "Least Unit Cost": calculate_luc,
    "Wagner-Whitin (DP)": calculate_ww_dp
}

select = int(input("Nhập 1 nếu bạn muốn so sánh, nhập 2 nếu muốn giải bài: "))

# Khối lệnh này để chạy so sánh nhiều lần và vẽ biểu đồ
if select == 1:
    NUM_SIMULATIONS = 10
    NUM_PERIODS = 60
    # ... (Các tham số mô phỏng)
    MIN_DEMAND = 10
    MAX_DEMAND = 100
    SETUP_COST = 200
    BUYING_COST = 50
    RATE_R = 0.1
    ZERO_DEMAND_PROB = 0.25
    HOLDING_COST = BUYING_COST * RATE_R
    
    # Tạo các dictionary để lưu kết quả chi phí và thời gian
    results_cost = {method_name: [] for method_name in methods}
    results_time = {method_name: [] for method_name in methods}
    
    print(f"Bắt đầu {NUM_SIMULATIONS} lần chạy mô phỏng với {NUM_PERIODS} kỳ/lần.")
    print(f"Chi phí Setup: {SETUP_COST}, Chi phí Mua hàng: {BUYING_COST}, Tỷ lệ r: {RATE_R}")
    print(f"==> Chi phí Holding trên mỗi đơn vị mỗi kỳ (h): {HOLDING_COST}\n")

    # Vòng lặp chính để chạy mô phỏng
    for i in range(NUM_SIMULATIONS):
        print(f"--- Mô phỏng lần {i+1}/{NUM_SIMULATIONS} ---")
        # Dùng seed để các lần chạy mô phỏng có thể lặp lại kết quả y hệt
        np.random.seed(42 + i) 
        current_demands = generate_random_demands(NUM_PERIODS, MIN_DEMAND, MAX_DEMAND, ZERO_DEMAND_PROB)
        
        # Chạy từng phương pháp trên cùng một bộ dữ liệu demands
        for method_name, method_func in methods.items():
            start_time = time.perf_counter() # Bắt đầu đếm giờ
            _, total_cost = method_func(current_demands, SETUP_COST, BUYING_COST, RATE_R)
            end_time = time.perf_counter() # Dừng đếm giờ
            execution_time = (end_time - start_time) * 1000 # Thời gian thực thi (ms)
            
            # Lưu kết quả vào dictionary
            results_cost[method_name].append(total_cost)
            results_time[method_name].append(execution_time)
            
            print(f"  {method_name}: Tổng Chi phí = {total_cost:,.2f}, Thời gian = {execution_time:.4f} ms")
        print("-" * 30)

    # --- 3. Trực quan hóa Kết quả (Không thay đổi) ---
    df_costs = pd.DataFrame(results_cost)
    df_times = pd.DataFrame(results_time)

    print("\n--- Chi phí Trung bình ---")
    print(df_costs.mean().sort_values().apply(lambda x: f"{x:,.2f}"))
    print("\n--- Thời gian Trung bình (ms) ---")
    print(df_times.mean().sort_values())

    # Vẽ biểu đồ so sánh chi phí
    plt.figure(figsize=(12, 6))
    sns.lineplot(data=df_costs, markers=True)
    plt.title('So sánh Tổng Chi phí Kế hoạch (gồm cả Mua hàng) qua các Lần chạy')
    plt.xlabel('Lần chạy mô phỏng')
    plt.ylabel('Tổng chi phí')
    plt.xticks(range(NUM_SIMULATIONS), [f'Run {i+1}' for i in range(NUM_SIMULATIONS)])
    plt.grid(True, linestyle='--', alpha=0.6)
    plt.legend(title='Phương pháp')
    plt.tight_layout()
    plt.show()

    # Vẽ biểu đồ so sánh thời gian
    plt.figure(figsize=(12, 6))
    sns.lineplot(data=df_times, markers=True)
    plt.title('So sánh Thời gian thực thi giữa các Phương pháp qua các Lần chạy (ms)')
    plt.xlabel('Lần chạy mô phỏng')
    plt.ylabel('Thời gian thực thi (ms)')
    plt.xticks(range(NUM_SIMULATIONS), [f'Run {i+1}' for i in range(NUM_SIMULATIONS)])
    plt.grid(True, linestyle='--', alpha=0.6)
    plt.legend(title='Phương pháp')
    plt.tight_layout()
    plt.show()

# Khối lệnh này để giải một bài toán cụ thể do người dùng nhập
else:
    try:
        # Lấy các thông số đầu vào từ người dùng
        raw_input_str = input("Nhập các giá trị demand (ví dụ: 10, 20, 30, 50, 60): ")
        demands = [float(item.strip()) for item in raw_input_str.split(',')]
        setup_cost = float(input("Nhập ordering cost (A): "))
        buying_cost = float(input("Nhập buying cost (C - giá mua mỗi đơn vị): "))
        r = float(input("Nhập tỷ lệ holding cost (r, ví dụ 0.1 cho 10%): "))
        
        holding_cost = buying_cost * r
        print(f"--> Holding cost (h) được tính là: {buying_cost} * {r} = {holding_cost}")

    except ValueError:
        print("Lỗi: Vui lòng chỉ nhập số và sử dụng đúng định dạng dấu phẩy.")
        exit()
        
    method_input = input(str("Nhập vào phương thức bạn muốn kiểm tra (L4L, Silver-Meal, Least Unit Cost, Wagner-Whitin (DP)): "))
    
    # Kiểm tra phương pháp và gọi hàm tương ứng
    if method_input in methods:
        function_to_run = methods[method_input]
        result_df, total_cost = function_to_run(demands, setup_cost, buying_cost, r)
        
        print(f"\n--- Kết quả cho phương pháp: {method_input} ---")
        print(result_df.to_string()) # Dùng to_string() để in toàn bộ DataFrame
        
        # Tách chi phí để dễ phân tích hơn
        total_buying_cost = result_df['Buying Cost'].sum()
        total_inventory_cost = total_cost - total_buying_cost
        print("\n--- Phân tích Chi phí ---")
        print(f"Tổng Chi phí Mua hàng   : {total_buying_cost:,.2f}")
        print(f"Tổng Chi phí Tồn kho     : {total_inventory_cost:,.2f} (Setup + Holding)")
        print(f"TỔNG CHI PHÍ KẾ HOẠCH    : {total_cost:,.2f}")
    else:
        print(f"\nLỗi: '{method_input}' không phải là một phương pháp hợp lệ.")
